// WARNING: Please don't edit this file. It was generated by Python/WinRT

// These two headers are part of the Python C Extension API
#include <Python.h>
#include <structmember.h>

#include <winrt/base.h>

#pragma once

namespace py
{
    template<typename T>
    constexpr bool is_basic_category_v = std::is_same_v<winrt::impl::category_t<T>, winrt::impl::basic_category>;

    template<typename T>
    constexpr bool is_class_category_v = std::is_same_v<winrt::impl::category_t<T>, winrt::impl::class_category>;

    template<typename T>
    constexpr bool is_interface_category_v = std::is_same_v<winrt::impl::category_t<T>, winrt::impl::interface_category>;

    template<typename T>
    constexpr bool is_delegate_category_v = std::is_same_v<winrt::impl::category_t<T>, winrt::impl::delegate_category>;

    template<typename T>
    constexpr bool is_enum_category_v = std::is_same_v<winrt::impl::category_t<T>, winrt::impl::enum_category>;

    // TODO: only enable py::winrt_wrapper for WinRT classes, interfaces and delegates
    template<typename T>
    struct winrt_wrapper
    {
        PyObject_HEAD
        T obj{ nullptr };
    };

    template<typename T>
    struct winrt_type
    {
        static PyObject* python_type;
    };

    inline WINRT_NOINLINE PyObject* to_PyErr() noexcept
    {
        try
        {
            throw;
        }
        catch (winrt::hresult_error const& e)
        {
            PyErr_SetString(PyExc_RuntimeError, winrt::to_string(e.message()).c_str());
        }
        catch (std::bad_alloc const&)
        {
            return PyErr_NoMemory();
        }
        catch (std::out_of_range const& e)
        {
            PyErr_SetString(PyExc_IndexError, e.what());
        }
        catch (std::invalid_argument const& e)
        {
            PyErr_SetString(PyExc_TypeError, e.what());
        }
        catch (std::exception const& e)
        {
            PyErr_SetString(PyExc_RuntimeError, e.what());
        }

        return nullptr;
    }

    template<typename T>
    PyObject* wrap(T instance)
    {
        // for runtime classes, verify the python type passed in matches the python type of the runtime class
        if constexpr (is_class_category_v<T> || is_interface_category_v<T>)
        {
            auto py_instance = PyObject_New(py::winrt_wrapper<T>, reinterpret_cast<PyTypeObject*>(py::winrt_type<T>::python_type));

            if (!py_instance)
            {
                return nullptr;
            }

            // PyObject_New doesn't call type's constructor, so manually initialize the wrapper's fields
            std::memset(&(py_instance->obj), 0, sizeof(py_instance->obj));
            py_instance->obj = instance;
            return reinterpret_cast<PyObject*>(py_instance);
        }

        PyErr_SetNone(PyExc_NotImplementedError);
        return nullptr;
    }

    template<typename T>
    inline void finalize(PyObject* arg) noexcept
    {
        reinterpret_cast<py::winrt_wrapper<T>*>(arg)->obj = nullptr;
    }

    template <typename T>
    struct converter
    {
        static PyObject* convert_to(T value) noexcept
        {
            PyErr_SetNone(PyExc_NotImplementedError);
            return nullptr;
        }

        static T convert_from(PyObject* obj)
        {
            throw winrt::hresult_not_implemented();
        }
    };

    template <>
    struct converter<bool>
    {
        static PyObject* convert_to(bool value) noexcept
        {
            return PyBool_FromLong(value ? 1 : 0);
        }

        static bool convert_from(PyObject* obj)
        {
            auto result = PyObject_IsTrue(obj);

            if (result == -1)
            {
                throw winrt::hresult_invalid_argument();
            }

            return result > 0;
        }
    };

    template <>
    struct converter<int32_t>
    {
        static PyObject* convert_to(int32_t value) noexcept
        {
            return PyLong_FromLong(value);
        }

        static int32_t convert_from(PyObject* obj)
        {
            auto result = PyLong_AsLong(obj);

            if (result == -1 && PyErr_Occurred())
            {
                throw winrt::hresult_invalid_argument();
            }

            return result;
        }
    };

    template <>
    struct converter<uint32_t>
    {
        static PyObject* convert_to(uint32_t value) noexcept
        {
            return PyLong_FromUnsignedLong(value);
        }

        static uint32_t convert_from(PyObject* obj)
        {
            auto result = PyLong_AsUnsignedLong(obj);

            if (result == -1 && PyErr_Occurred())
            {
                throw winrt::hresult_invalid_argument();
            }

            return result;
        }
    };

    template <>
    struct converter<double>
    {
        static PyObject* convert_to(double value) noexcept
        {
            return PyFloat_FromDouble(value);
        }

        static double convert_from(PyObject* obj)
        {
            auto result = PyFloat_AsDouble(obj);

            if (result == -1 && PyErr_Occurred())
            {
                throw winrt::hresult_invalid_argument();
            }

            return result;
        }
    };

    struct pystring
    {
        wchar_t* buffer{ nullptr };
        std::wstring_view::size_type size{};

        explicit pystring(PyObject* obj)
        {
            Py_ssize_t py_size;
            buffer = PyUnicode_AsWideCharString(obj, &py_size);
            if (buffer != nullptr)
            {
                size = static_cast<std::wstring_view::size_type>(py_size);
            }
        }

        pystring(pystring& other) = delete;
        pystring& operator=(pystring const&) = delete;

        pystring(pystring&& other) noexcept : buffer(other.buffer), size(other.size)
        {
            other.buffer = nullptr;
        }

        pystring& operator=(pystring&& rhs)
        {
            std::swap(buffer, rhs.buffer);
            size = rhs.size;
        }

        operator bool() const noexcept
        {
            return buffer != nullptr;
        }

        ~pystring()
        {
            PyMem_Free(buffer);
        }
    };

    struct pystringview : public pystring, public std::wstring_view
    {
        explicit pystringview(PyObject* obj) : pystring(obj), std::wstring_view(pystring::buffer, pystring::size)
        {
        }
    };

    template <>
    struct converter<winrt::hstring>
    {
        static PyObject* convert_to(winrt::hstring value) noexcept
        {
            return PyUnicode_FromWideChar(value.c_str(), value.size());
        }

        static pystringview convert_from(PyObject* obj)
        {
            pystringview str{ obj };

            if (!str)
            {
                throw winrt::hresult_invalid_argument();
            }

            return str;
        }
    };

    template<typename T>
    PyObject* convert_primitive_to(T value) noexcept
    {
        return converter<T>::convert_to(value);
    }

    template<typename T>
    PyObject* convert_enum_to(T instance)
    {
        using enum_type = std::underlying_type_t<T>;
        return convert_primitive_to<enum_type>(static_cast<enum_type>(instance));
    }

    template<typename T>
    auto convert_from(PyObject* arg)
    {
        if (!arg)
        {
            throw winrt::hresult_invalid_argument();
        }

        if constexpr (is_class_category_v<T>)
        {
            if (Py_TYPE(arg) != reinterpret_cast<PyTypeObject*>(py::winrt_type<T>::python_type))
            {
                throw winrt::hresult_invalid_argument();
            }

            return reinterpret_cast<py::winrt_wrapper<T>*>(arg)->obj;
        }
        else if constexpr (is_interface_category_v<T>)
        {
            if (Py_TYPE(arg) == reinterpret_cast<PyTypeObject*>(py::winrt_type<T>::python_type))
            {
                return reinterpret_cast<py::winrt_wrapper<T>*>(arg)->obj;
            }

            // TODO: need to check to make sure arg is a WinRT wrapper class before doing this reinterpret cast
            return reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(arg)->obj.as<T>();
        }
        else if constexpr (is_enum_category_v<T>)
        {
            return static_cast<T>(convert_from<std::underlying_type_t<T>>(arg));
        }
        else if constexpr (is_basic_category_v<T>)
        {
            return converter<T>::convert_from(arg);
        }
        else
        {
            static_assert(false, "convert_from not impl");
        }
    }

    template<typename T>
    auto convert_from(PyObject* args, int index)
    {
        return convert_from<T>(PyTuple_GetItem(args, index));
    }
}
